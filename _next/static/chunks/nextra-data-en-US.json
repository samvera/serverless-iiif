{"/about":{"title":"About","data":{"iiif-in-the-cloud#IIIF in the Cloud":"Access is bursty by nature\nTile requests are at least an order of magnitude burstier\nVery hard to scale a server-based solution in a way that can handle the bursts without wasting capacity (and money)","solution#Solution":"","under-the-hood#Under the Hood":"","libvips#libvips":"“A demand-driven, horizontally threaded image processing library”\nVery fast and extremely lightweight\nCan perform more than 300 different image manipulation operations\nSupports a large number of image formats\nMost importantly (for our purposes), it supports multi-resolution images\nand tiling\nDocumentation ↗","sharp#sharp":"Fast native Node.js wrapper for libvips\nSupports seeking and streaming of image data without making a local copy\nDocumentation ↗","contributors#Contributors":"Michael B. Klein - Northwestern University Libraries\nJustin Gondron\nRob Kaufman - Notch 8\nEdward Silverton - Mnemoscene\nTrey Pendragon - Princeton University Libraries\nTheia Wolfe","license#License":"Serverless IIIF is available under the Apache 2.0 license."}},"/docs/advanced-usage/cors":{"title":"Cross-Origin Request Sharing (CORS)","data":{"":"For security reasons, web browsers have built in limits on what sort of requests can be made to a given domain from a page hosted under a different domain. Since this is a common use case for IIIF (resources embedded in pages whose domains differ from that of the server), IIIF interactions are particularly susceptible to these limits.The mechanism for determining which of these requests should be allowed or blocked is known as Cross-Origin Resource Sharing, or CORS. A full explanation of CORS is beyond the scope of this project, but the SAM deploy template contains five parameters relating to how the IIIF server handles CORS:\nCorsAllowCredentials contains the value that will be returned in the Access-Control-Allow-Credentials response header.\nCorsAllowHeaders contains the value that will be returned in the Access-Control-Allow-Headers response header.\nCorsAllowOrigin contains the value that will be returned in the Access-Control-Allow-Origin response header. In addition, a special value, REFLECT_ORIGIN, instructs the IIIF server to copy the value of the incoming request's Origin header into the Access-Control-Allow-Origin response header.\nCorsExposeHeaders contains the value that will be returned in the Access-Control-Expose-Headers response header.\nCorsMaxAge contains the value that will be returned in the Access-Control-Max-Age response header.\nThe default values will work in most circumstances, but if you need the IIIF server to accept requests that include credentials or other potentially sensitive information (e.g., Authorization and/or Cookie headers), you'll need to set CorsAllowOrigin to REFLECT_ORIGIN and CorsAllowCredentials to true. Other settings allow further customization."}},"/docs/advanced-usage/request-response-functions":{"title":"Request Response Functions","data":{"requestresponse-functions#Request/Response Functions":"The IIIF service can be heavily customized through the use of CloudFront Functions or Lambda@Edge Functions attached to a CloudFront distribution in front of the service. It's important to understand the four stages of CloudFront processing in order to know where a given type of customization belongs.\nA viewer-request function will be called on every request, cached or not. This is the appropriate place to attach\na function that performs authorization, authentication, or anything else whose result should not be cached.\nAn origin-request function will only be called when CloudFront refreshes the content from the origin (e.g., the IIIF server).\nIt's the appropriate place to attach a function that should be cached, such as S3 file resolution or the retrieval of\nimage dimensions.\nSimilarly, the origin-response and viewer-response functions are called after the IIIF server returns its response\nand before CloudFront passes it on to the viewer, respectively. They can be used to alter the response in a way that is\neither cached or ephemeral.","examples#Examples":"These examples use CloudFront Functions. Lambda@Edge functions are slightly more complicated in terms of the event structure but the basic idea is the same.","simple-authorization#Simple Authorization":"function handler(event) {\n    if (notAuthorized) { // based on something in the event.request\n       return {\n         statusCode: 403,\n         statusDescription: 'Unauthorized'\n       };\n    };\n    return event.request;\n}","custom-file-location--image-dimensions#Custom File Location / Image Dimensions":"function handler(event) {\n  var request = event.request;\n  request.headers['x-preflight-location'] = [{value: 's3://image-bucket/path/to/correct/image.tif'}];\n  request.headers['x-preflight-dimensions'] = [{value: JSON.stringify({ width: 640, height: 480 })}];\n  return request;\n}\nThe x-preflight-dimensions header can take several shapes:\n{ width, height } (or [{ width, height }]) - a straightforward, single-resolution image\n[{ width, height }, { width, height }, ...] - a multi-resolution image with pages of the specified sizes\n{ width, height, pages } - a multi-resolution image with the specified number of pages, each half the size of the one before\n{ width, height, limit } - a multi-resolution image in which the smallest width and height are both less than the specified limit\nFor example, the following dimension values would all describe the same pyramidal image:\n[{ width: 2048, height: 1536 }, { width: 1024, height: 768 }, { width: 512, height: 384 }]\n{ width: 2048, height: 1536, pages: 3 }\n{ width: 2048, height: 1536, limit: 480 }\nThe limit calculator will keep going until both dimensions are less than the limit, not less than or equal to. So a limit: 512 on the third example above would generate a fourth page at { width: 256, height: 192 }.\nIf you plan to use CloudFront functions to add either of the above x-preflight- headers to incoming requests, you must set the value of the Preflight parameter to true when deploying serverless-iiif. The function will only look for the preflight headers if this environment variable is true. This prevents requests from including those headers directly if no preflight function is present. If you do use a preflight function, make sure it strips out any x-preflight-location and x-preflight-dimensions headers that it doesn't set itself."}},"/docs/communities/iiif":{"title":"Iiif","data":{}},"/docs/communities/samvera":{"title":"Samvera","data":{}},"/docs/contributors":{"title":"Contributors","data":{"":"Michael B. Klein\nJustin Gondron\nRob Kaufman\nEdward Silverton\nTrey Pendragon\nTheia Wolfe"}},"/docs/custom-sharp-layer":{"title":"Custom Sharp Layer","data":{"":"This lambda uses the Sharp layer from https://github.com/samvera-labs/sharp-jp2-lambda-layer in order to get a version of Sharp with jp2 support.You can build your own local version using that code and then deploy your own layer and set that layer in your SAM template."}},"/docs/how-to-contribute":{"title":"How to Contribute?","data":{"":"If you're working on a PR for this project, create a feature branch off of main.This repository follows the Samvera Community Code of Conduct and language recommendations. Please do not create a branch called master for this repository or as part of your pull request; the branch will either need to be removed or renamed before it can be considered for inclusion in the code base and history of this repository."}},"/docs":{"title":"serverless-iiif","data":{"description#Description":"A cost-effective, infinitely scalable IIIF 2.1 and 3.0 image API compliant service packaged as an AWS Serverless Application with minimum setup and no maintenance. Suitable for large institutional collections or small digital humanities projects.","components#Components":"A simple Lambda Function wrapper for the iiif-processor module.\nA Lambda Function URL that is used to invoke the IIIF API via HTTPS.\nA Lambda Layer containing all the dependencies for the Lambda Function.","prerequisites#Prerequisites":"Some basic knowledge of AWS.\nAn Amazon Web Services account with permissions to create resources via the console and/or command line.\nAn Amazon S3 bucket to hold the source images to be served via IIIF.\nNote: The Lambda Function will be granted read access to this bucket.","license#License":"serverless-iiif is available under the Apache 2.0 license."}},"/docs/notes":{"title":"Notes","data":{"":"serverless-iiif takes advantage of AWS Lambda URLs' streaming response functionality to overcome the 6MB response limit that previous versions were subject to. Instead of a hard limit of 6MB, there is now a soft limit of approximately 20MB for each response. This limit can be adjusted by opening a support ticket with AWS requesting a quota increase. In addition, the streaming rate for the first 6MB of each response is uncapped; data over 6MB is capped at 2MB/s."}},"/docs/quick-start/deleting-the-app":{"title":"Deleting the application","data":{"":"If you deployed the application on its own, the easiest way to delete the application is either from the Lambda Applications Console or by deleting its CloudFormation Stack.If you deployed from the command line, you can also use the npm run delete command.If you deployed using an infrastructure tool such as AWS CloudFormation or Terraform, you should use that tool's destroy/teardown functionality to remove the IIIF stack as well."}},"/docs/quick-start/deployment-command-line":{"title":"Deploying via the Command Line","data":{"prerequisites#Prerequisites":"Docker\nAWS CLI\nAWS SAM CLI v1.91 or greater","step-1#Step 1":"Make sure the AWS CLI is properly configured with credentials that have sufficient access to manage IAM, S3, and Lambda resources.","step-2#Step 2":"Clone this repository.","step-3#Step 3":"Copy deploy.yml.example to deploy.yml. Update the various values under parameter_overrides within.","step-4#Step 4":"Build the application:\n$ npm run build","step-5#Step 5":"Deploy the application using one of the following:\n# To be prompted for all configuration values before deploying\n$ npm run deploy-guided\n# To deploy using the current configuration, prompting only for changeset confirmation\n$ npm run deploy\nIf you use the guided deploy, you'll be prompted for various configuration parameters, confirmations, and acknowledgments of specific issues (particularly the creation of IAM resources and the deployment of an open/unauthenticated Lambda Function URL). Otherwise, you'll simply be asked to confirm the calculated changeset.","step-6#Step 6":"Follow the prompts to complete the deployment process and get the resulting endpoint."}},"/docs/quick-start/deployment-sam":{"title":"Deploying via the AWS Serverless Application Repository","data":{"":"serverless-iiif is distributed and deployed via the AWS Serverless Application Repository. To deploy it using the AWS Console:","step-1#Step 1":"Find the serverless-iiif application in the AWS Serverless Application Repository.","step-2#Step 2":"Make sure your currently selected region (in the console's top navigation bar) is the one you want to deploy to.","step-3#Step 3":"Scroll down to the Application settings section.","step-4#Step 4":"Configure the deploy template:\nGive your stack a unique Application name\nEnter the name of the SourceBucket the service will serve images from\nCheck the box acknowledging that the app will create a custom IAM roles and resource policies (and if deploying the Caching version, that it will also deploy a nested application)\nOptional: Enter or change any other parameters that apply to your desired configuration.","step-5#Step 5":"Click Deploy.","step-6#Step 6":"When all the resources are properly created and configured, the new stack should be in the CREATE_COMPLETE stage. If there's an error, it will delete all the resources it created, roll back any changes it made, and eventually reach the ROLLBACK_COMPLETE stage.","step-7#Step 7":"Click the CloudFormation stack link.","step-8#Step 8":"Click the Outputs tab to see (and copy) the IIIF Endpoint URL."}},"/docs/quick-start":{"title":"Index","data":{"":"serverless-iiif is deployed as a Lambda Function URL, in the lambda-url.AWS_REGION.on.aws domain (e.g., https://fu90293j0pj902j902c32j902.lambda-url.us-east-1.on.aws/iiif/2/). In order to use a custom domain name, or other features like caching and pre/post-processing functions, you'll have to set up a CloudFront distribution."}},"/docs/quick-start/infrastructure":{"title":"Deploying via Infrastructure Tools","data":{"":"You will most likely want to deploy serverless-iiif as part of a larger infrastructure stack. This stack might include a caching layer (AWS CloudFront), functions to customize the services behavior, a custom domain name, and more. This section provides documentation and examples of how to deploy the service using AWS CloudFormation or Terraform."}},"/docs/source-images":{"title":"Source Images","data":{"":"The S3 key of any given file, minus the extension, is its IIIF ID. For example, if you want to access the image manifest for the file at abcdef.tif, you would get https://.../iiif/2/abcdef/info.json. If your key contains slashes, they must be URL-encoded: e.g., ab/cd/ef/gh.tif would be at https://.../iiif/2/ab%2Fcd%2Fef%2Fgh/info.json. (This limitation could easily be fixed by encoding only the necessary slashes in the incoming URL before handing it off to the IIIF processor, but that's beyond the scope of the demo.)iiif-processor can use any image format natively supported by libvips, including JPEG 2000 (.jp2), but best results will come from using tiled, multi-resolution TIFFs. The Lambda Function wrapper included in this application assumes a .tif extension unless you set ResolverTemplate in your .env file.\nSome versions of libvips and libjpeg have an issue with JPEG-compressed pyramidal TIFF images that include more than 3 channels (e.g.,\nalpha channels). If you find that serverless-iiif returns an error for an image request or isn't rendering as you'd expect, try removing any additional channels beyond red, green, and blue.","image-metadata#Image Metadata":"serverless-iiif will probe each source image for its dimensions before any other processing takes place. Because this process can be time consuming, especially for large files, serverless-iiif first looks for fields calls x-amz-meta-width and x-amz-meta-height in the source file's S3 Object Metadata before trying to load dimensions from the image itself. If those properties are present, they will be used instead.","creating-tiled-tiffs#Creating tiled TIFFs":"","using-the-vips-command-line#Using the VIPS command line":"# For a 3-channel source image\nvips tiffsave source_image.tif output_image.tif --tile --pyramid --compression jpeg --tile-width 256 --tile-height 256\n# For a source image with an alpha channel\nvips extract_band source_image.tif temp_image.v 0 --n 3 \\\n  && vips tiffsave temp_image.v output_image.tif --tile --pyramid --compression jpeg --tile-width 256 --tile-height 256 \\\n  && rm temp_image.v","using-imagemagick#Using ImageMagick":"convert source_image.tif -alpha off \\\n  -define tiff:tile-geometry=256x256 \\\n  -define tiff:generate-pyramids=true \\\n  -compress jpeg \\\n  'ptif:output_image.tif'","using-graphicsmagick#Using GraphicsMagick":"gm convert source_image.tif -flatten \\\n  -define tiff:tile-geometry=256x256 \\\n  -compress jpeg \\\n  'ptif:output_image.tif'"}},"/docs/testing":{"title":"Testing","data":{"testing#Testing":"If tests are run locally they will start in \"watch\" mode. If a CI environment is detected they will only run once. From the project root run:\nnpm test\nTo generate a code coverage report run:\nnpm test --coverage"}},"/":{"title":"Serverless IIIF – Serve images via IIIF","data":{}},"/docs/quick-start/infrastructure/cloudformation":{"title":"Cloudformation","data":{"":"Installing serverless-iiif as part of a CloudFormation template makes it easy to integrate the service with other components. Please refer to the example and the CloudFormation documentation for more information on how you might tailor these templates to your own needs and deploy them to AWS.","syntax#Syntax":"To declare this entity in your AWS CloudFormation template, use the following syntax:","properties#Properties":"","example#Example":"This example template will deploy a full application stack consisting of:\nA serverless-iiif image server\nA CloudFront distribution with a custom hostname and SSL certificate"}},"/docs/quick-start/infrastructure/terraform":{"title":"Terraform","data":{"":"The serverless-iiif GitHub repository includes a  that can be used as a drop-in component in any\nTerraform manifest. Please refer to the documentation and examples below, as well as the Terraform documentation\nfor more information on how you might use these tools to deploy your own custom stack to AWS.","undefined#Required Inputs":"These variables must be set in the module block when using this module.","undefined#Optional Inputs":"These variables have default values and don't have to be set to use this module. You may set these variables to override their default\nvalues.","undefined#Minimal Example":"module \"serverless_iiif\" {\n  source          = \"github.com/samvera/serverless-iiif//extras/terraform\"\n  source_bucket   = \"iiif-images\"\n  stack_name      = \"my-iiif-service\"\n}","undefined#(Almost) Full Example":"module \"serverless_iiif\" {\n  source                    = \"github.com/samvera/serverless-iiif//extras/terraform\"\n  source_bucket             = \"iiif-images\"\n  stack_name                = \"my-iiif-service\"\n  cors_allow_credentials    = true\n  cors_allow_headers        = \"X-Custom-Header,Upgrade-Insecure-Requests\"\n  cors_allow_origin         = \"REFLECT_ORIGIN\"\n  cors_expose_headers       = \"Content-Encoding\"\n  cors_max_age              = 600\n  force_host                = \"iiif.my-domain.edu\"\n  iiif_lambda_memory        = 2048\n  iiif_lambda_timeout       = 120\n  pixel_density             = 600\n  preflight                 = true\n  resolver_template         = \"iiif/%s.tif\"\n  tags = {\n    Project = \"my-image-service\"\n  }\n}"}}}